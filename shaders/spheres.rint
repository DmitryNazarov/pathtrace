#version 460
#extension GL_EXT_ray_tracing : require
#extension GL_EXT_ray_query : require
#extension GL_EXT_nonuniform_qualifier : enable
#extension GL_GOOGLE_include_directive : enable
#include "raycommon.glsl"

layout(binding = 5, set = 0) buffer Spheres { Sphere s[]; } spheres;

// Ray-Sphere intersection
// http://viclw17.github.io/2018/07/16/raytracing-ray-sphere-intersection/
float hitSphere(const Sphere s, const Ray r)
{
	vec3 oc = r.origin - s.pos;
	float a = dot(r.direction, r.direction);
	float b = 2.0 * dot(oc, r.direction);
	float c = dot(oc, oc) - s.radius * s.radius;
	float discriminant = b * b - 4 * a * c;
	if(discriminant < 0)
	{
		return -1.0;
	}
	else
	{
		return (-b - sqrt(discriminant)) / (2.0 * a);
	}
}

void main()
{
	Sphere s = spheres.s[gl_PrimitiveID];
	Ray ray, rayTransf;
	ray.origin    = gl_WorldRayOriginEXT;
	ray.direction = normalize(gl_WorldRayDirectionEXT);
	rayTransf.origin    = (s.invertedTransform * vec4(ray.origin, 1.0f)).xyz;;
	rayTransf.direction = (normalize(s.invertedTransform * vec4(ray.direction, 0.0f))).xyz;

	float tHit = hitSphere(s, rayTransf);
	if(tHit > 0)
	{
		vec3 intersectionPointTransf = rayTransf.origin + tHit * rayTransf.direction;
		vec3 intersectionPoint = (s.transform * vec4(intersectionPointTransf, 1.0f)).xyz;
		tHit = length(intersectionPoint - ray.origin);
		reportIntersectionEXT(tHit, 0);
	}
}